/*	Filename:	MoveItBoard.as		Purpose:	Board class for Move It! -- responsible for all visuals associated with Move It!		Author:		Justin Bachorik		Date:		3/20/09	*/package {		import flash.display.MovieClip;	import flash.utils.*;	import flash.xml.*;	import flash.net.*;	import caurina.transitions.Tweener;	import flash.events.*;		public class MoveItBoard extends MovieClip {				// class constants here		public static const SQUARE_SIDE = 30;		public static const MOVE_TIME = .2;						// instance variables here		var mySize:Number;		var nextBoardX:Number = 0;		var nextBoardY:Number = 0;		var mySquares:Array;		var myHero:Hero;		var myHeroX:Number;		var myHeroY:Number;		var myGoalX:Number;		var myGoalY:Number;				// constructor here		public function MoveItBoard(boardSize:Number):void {						// initialize variables			mySquares = new Array();						// store the arguments to the class			mySize = boardSize;						// set up the visuals			setUpBoard();					}				// function to set up the initial visual appearance of the board		private function setUpBoard():void {						// loop through all the locations, add blank squares to each one			for(var i:Number = 0; i < mySize; i++) {								// initialize a new array for the row				mySquares[i] = new Array();								for(var j:Number = 0; j < mySize; j++) {										mySquares[i][j] = new BoardSquare();					//this.addChild(new BoardSquare());					//this.getChildAt(this.numChildren-1).x = nextBoardX;					//this.getChildAt(this.numChildren-1).y = nextBoardY;					//trace(this.getChildAt(this.numChildren-1)).x;					mySquares[i][j].x = nextBoardX;					mySquares[i][j].y = nextBoardY;										this.addChild(mySquares[i][j]);										nextBoardX += SQUARE_SIDE;				}				nextBoardY += SQUARE_SIDE;				nextBoardX = 0;			}					}	// end setUpBoard				// function to add a wall to the board		public function addWall(xPos:Number, yPos:Number) {						mySquares[xPos][yPos] = new Wall();			this.addChild(mySquares[xPos][yPos]);			mySquares[xPos][yPos].x = xPos * SQUARE_SIDE;			mySquares[xPos][yPos].y = yPos * SQUARE_SIDE;					}  // end addWall				// functinon to add the goal to the board		public function addGoal(xPos:Number, yPos:Number) {						mySquares[xPos][yPos] = new Goal();			this.addChild(mySquares[xPos][yPos]);			mySquares[xPos][yPos].x = xPos * SQUARE_SIDE;			mySquares[xPos][yPos].y = yPos * SQUARE_SIDE;						myGoalX = xPos;			myGoalY = yPos;				}				// function to add a powerup to the board		public function addPowerUp(xPos:Number, yPos:Number, strength:Number) {						mySquares[xPos][yPos] = new PowerUp(strength);			this.addChild(mySquares[xPos][yPos]);			mySquares[xPos][yPos].x = xPos * SQUARE_SIDE;			mySquares[xPos][yPos].y = yPos * SQUARE_SIDE;					}				// function to add the Hero to the board		public function addHero(xPos:Number, yPos:Number) {			myHero = new Hero();			this.addChild(myHero);			myHero.x = xPos * SQUARE_SIDE;			myHero.y = yPos * SQUARE_SIDE;						// these vars track hero's board position (as opposed to graphical position)			myHeroX = xPos;			myHeroY = yPos;		}	// end addHero				// function to check for a win 		public function isWin():Boolean {			return(myHeroX == myGoalX && myHeroY == myGoalY);		}				// function to evaluate whether a move is possible		public function canMoveHeroBy(deltaX:Number, deltaY:Number):Boolean {			// code for wall-checking and more						// new potential positions			var newX:Number = myHeroX + deltaX;			var newY:Number = myHeroY + deltaY;						// check left bound			if(newX < 0) return false;			// check right bound			if(newX > mySize-1) return false;			// check top bound			if(newY < 0) return false;			// check bottom bound			if(newY > mySize-1) return false;						// check for wall			if(String(getClass(mySquares[newX][newY])) == '[class Wall]') {				return false;			}						return true;		}				// function to actually move the hero on the board		public function moveHero(deltaX:Number, deltaY:Number):void {						// update graphics			Tweener.addTween(myHero, {x: (myHero.x + deltaX * SQUARE_SIDE), time: MOVE_TIME, onComplete: function() { this.parent.parent.setMovesAllowed();}});			Tweener.addTween(myHero, {y: (myHero.y + deltaY * SQUARE_SIDE), time: MOVE_TIME, onComplete: function() { this.parent.parent.setMovesAllowed();}});						// update hero tracking			myHeroX += deltaX;			myHeroY += deltaY;					} // end function moveHero				// function to check if the hero is on top of a powerup		public function isPowerUp():Boolean {			return (String(getClass(mySquares[myHeroX][myHeroY])) == '[class PowerUp]')		}				// function to get the strength of a powerup, only called if the hero is on top of the powerup		public function getPowerUpStrength():Number {			return mySquares[myHeroX][myHeroY].getStrength();		} // end getPowerUpStrength				// function to remove the powerup from the board		public function removePowerUp():void {			this.removeChild(mySquares[myHeroX][myHeroY]);			mySquares[myHeroX][myHeroY] = new BoardSquare();			//this.addChild(mySquares[myHeroX][myHeroY]);		}						// helper function to get classnames		private static function getClass(obj:Object):Class {        	return Class(getDefinitionByName(getQualifiedClassName(obj)));   		}	// end getClass					} // end class MoveItBoard	} // end package